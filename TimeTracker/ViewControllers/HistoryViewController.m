//
//  HistoryViewController.m
//  TimeTracker

#import "HistoryViewController.h"
#import "AppDelegate.h"
#import "History.h"
#import "Activity.h"
#import "HistoryCell.h"
#import "DataExportHelper.h"
#import "CustomButton.h"
#import "CoreDataHandler.h"
#import <QuartzCore/QuartzCore.h>

@interface HistoryViewController ()
{
    BOOL isExportingNewItems;
}
/// dataexporthelper property
@property (nonatomic, strong) DataExportHelper *dataExportHelper;
@end

@implementation HistoryViewController

/**
 * Called when the user pressed the delete button.
 * @param sender button where the press was executed
 */
- (IBAction)deleteItems:(id)sender
{
    [self clearHistory];
}

/**
 * Called when the user pressed a button on the actionsheet.
 * @param actionSheet actionsheet where the button touch happened.
 * @param buttonIndex which button was pressed.
 */
- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex
{
    if (buttonIndex == 0)
    {
        (actionSheet.tag == 0 ? [self exportOnlyNewOnes:NO] : [self clearTable]);
    }
    else if(buttonIndex == 1)
    {
        (actionSheet.tag == 0 ? [self exportOnlyNewOnes:YES] : [self exportOnlyNewOnes:NO]);
    }
    else if(buttonIndex == 2)
    {
        (actionSheet.tag == 0 ? nil : [self exportOnlyNewOnes:YES]);
    }
}

/**
 * Export object in email.
 * @param newOnes boolean value to determine whether you're exporting new objects or all of them.
 */
- (void)exportOnlyNewOnes:(BOOL)newOnes
{
    if ([MFMailComposeViewController canSendMail])
    {
        NSData *data = nil;
        NSString *fileName = @"";
        if (newOnes) {
            data = [self.dataExportHelper exportAllHistoryItems:[CoreDataHandler notUploadedHistoryItems]];
            fileName = @"New_activities.csv";
        }else{
            data = [self.dataExportHelper exportAllHistoryItems:self.fetchController.fetchedObjects];
            fileName = @"All_activities.csv";
        }
        MFMailComposeViewController *mailer = [[MFMailComposeViewController alloc] init];
        mailer.mailComposeDelegate = self;
        [mailer setSubject:@"Exporting my activites from TimeTracker app"];
        [mailer setMessageBody:@"This email was generated by your iPhone application: TimeTracker.\n "
         @" You will find a file called All_activities.csv as an attachment with all of your activities."
                        isHTML:NO];
        [mailer addAttachmentData:data mimeType:@"text/csv" fileName:fileName];
        [self presentModalViewController:mailer animated:YES];
    }
    else
    {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Status:"
                                                        message:@"Your phone is not currently configured to send mail."
                                                       delegate:nil
                                              cancelButtonTitle:@"ok"
                                              otherButtonTitles:nil];
        
        [alert show];
    }
}

/**
 * Check if there are any objects that haven't been exported yet. If there are, then display an actionsheet, whether they really want to clear all items.
 */
- (void)clearHistory
{
    int notUploadedFound = 0;
    NSArray *historyList = [self.fetchController fetchedObjects];
    History *history = nil;
    for(int i = 0; i < [historyList count]; ++i)
    {
        history = (History *)[historyList objectAtIndex:i];
        if ([[history uploaded] isEqualToNumber:[NSNumber numberWithInt:0]]){
            notUploadedFound++;
            break;
        }
    }
    if (notUploadedFound == 1)
    {
        UIActionSheet *actionsheet = [[UIActionSheet alloc] initWithTitle:@"Do you really want to clear the history list? "
                                                                          @"There are some activities which haven't been exported yet!"
                                                                 delegate:self
                                                        cancelButtonTitle:@"Cancel"
                                                   destructiveButtonTitle:@"Clear"
                                                        otherButtonTitles:@"Export All", @"Export new", nil];
        [actionsheet setTag:1];
        [actionsheet showInView:self.view];
        notUploadedFound = 0;
    }
    else
    {
        [self clearTable];
        notUploadedFound = 0;
    }
}

/**
 * Clear the tableView and remove all history objects from core data.
 */
- (void)clearTable
{
    AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];
    NSFetchRequest *request =[[NSFetchRequest alloc] init];
    NSEntityDescription *entity = [NSEntityDescription entityForName:@"History"
                                              inManagedObjectContext:appDelegate.managedObjectContext];
    [request setEntity:entity];
    NSError *error = nil;
    NSArray *fetchResults = [appDelegate.managedObjectContext executeFetchRequest:request error:&error];
    if(fetchResults == nil)
    {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Error"
                                                        message:@"A problem occured. Please restart your application by pressing the Home button"
                                                       delegate:nil
                                              cancelButtonTitle:@"OK"
                                              otherButtonTitles:nil];
        [alert show];
    }
    NSEnumerator *enumerator = [fetchResults objectEnumerator];
    History *setObject = nil;
    while( (setObject = [enumerator nextObject]) != nil)
    {
        [appDelegate.managedObjectContext deleteObject:(NSManagedObject*)setObject];
    }
    [appDelegate saveContext];
}

/**
 * Special getter for dataExportHelper. Because it costs a lot to initalize a dateformatter for every cell.
 */
- (DataExportHelper*)dataExportHelper
{
    if (_dataExportHelper == nil) {
        _dataExportHelper = [[DataExportHelper alloc] init];
    }
    return _dataExportHelper;
}

/**
 * Called when the user pressed the export button.
 * @param sender button where the press was executed
 */
- (IBAction)exportItems:(id)sender
{
    UIActionSheet *actionsheet = [[UIActionSheet alloc] initWithTitle:@"Do you want to export all activities or just the ones that haven't been exported yet?"
                                                             delegate:self
                                                    cancelButtonTitle:@"Cancel"
                                               destructiveButtonTitle:nil
                                                    otherButtonTitles:@"All", @"New ones", nil];
    [actionsheet setTag:0];
    [actionsheet showInView:self.view];
}

/**
 * Delegate method of composing an email. If the email has been sent, refresh all the objects that were sent and update their uploaded property to YES.
 * @param controller controller that responsible for sending the email.
 * @param result what happened during sending.
 * @param error Error to handle.
 */
- (void)mailComposeController:(MFMailComposeViewController*)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError*)error
{
    switch (result)
    {
        case MFMailComposeResultCancelled:
            break;
        case MFMailComposeResultSaved:
        {
            UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Email saved"
                                                            message:@"You can find it in the drafts folder."
                                                           delegate:nil
                                                  cancelButtonTitle:@"OK"
                                                  otherButtonTitles:nil];
            [alert show];
            break;
        }
        case MFMailComposeResultSent:
        {
            AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];
            NSArray *historyItems = [self.fetchController fetchedObjects];
            History *history = nil;
            for (int i = 0; i < [historyItems count]; i++)
            {
                history = [historyItems objectAtIndex:i];
                if ([[history uploaded] isEqualToNumber:[NSNumber numberWithBool:NO]])
                {
                    [history setUploaded:[NSNumber numberWithBool:YES]];
                }
            }
            [appDelegate saveContext];
            [self loadCoreDataEntities];
            break;
        }
        case MFMailComposeResultFailed:{
            UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Error"
                                                            message:@"An error occured while sending your message."
                                                           delegate:nil
                                                  cancelButtonTitle:@"OK"
                                                  otherButtonTitles:nil];
            [alert show];
            break;
        }
    }
    [self dismissModalViewControllerAnimated:YES];
}

#pragma mark  Fetch controller delegate methods
/**
 * Special getter for NSFetchedResultsController to fetch history entities from core data. Because it costs a lot to initalize a NSFetchedResultsController.
 * @return NSFetchedResultsController a fetchController
 */
- (NSFetchedResultsController*)fetchController
{
    if (_fetchController != nil) {
        return _fetchController;
    }
    
    AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];
    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
    NSEntityDescription *entity = [NSEntityDescription entityForName:@"History" inManagedObjectContext:appDelegate.managedObjectContext];
    [fetchRequest setEntity:entity];
    
    NSSortDescriptor *nameDescriptor = [[NSSortDescriptor alloc] initWithKey:@"startDate" ascending:NO];
    NSArray *sortDescriptors = [[NSArray alloc] initWithObjects:nameDescriptor, nil];
    [fetchRequest setSortDescriptors:sortDescriptors];
    _fetchController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest
                                                           managedObjectContext:appDelegate.managedObjectContext
                                                             sectionNameKeyPath:@"saveTime"
                                                                      cacheName:@"History"];
    _fetchController.delegate = self;
    return _fetchController;
}

/**
 * Special getter for dateFormatter. Because it costs a lot to initalize a dateformatter for every cell.
 */
+ (NSDateFormatter*)dateFormatter
{
    static NSDateFormatter *instance = nil;
    if (instance == nil) {
        instance = [[NSDateFormatter alloc] init];
    }
    instance.dateFormat = @"HH:mm:ss";
    return instance;
}

/**
 * Notifies the receiver that the fetched results controller is about to start processing of one or more changes due to an add, remove, move, or update.
 * @param controller The fetched results controller that sent the message.
 */
- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller
{
    [self.myTableView beginUpdates];
}

/**
 * Notifies the receiver that a fetched object has been changed due to an add, remove, move, or update. The fetched results controller reports changes to its section before changes to the fetch result objects.
 * @param controller The fetched results controller that sent the message.
 * @param anObject The object in controller’s fetched results that changed.
 * @param indexPath The index path of the changed object (this value is nil for insertions).
 * @param type The type of change. For valid values see “NSFetchedResultsChangeType”.
 * @param newIndexPath The destination path for the object for insertions or moves (this value is nil for a deletion).
 */
- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath *)newIndexPath
{
    UITableView *tableView = self.myTableView;
    switch(type) {
            
        case NSFetchedResultsChangeInsert:
            [tableView insertRowsAtIndexPaths:[NSArray arrayWithObject:newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
            break;
            
        case NSFetchedResultsChangeDelete:
            [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationLeft];
            break;
            
        case NSFetchedResultsChangeUpdate:
            [self configureCell:(HistoryCell*)[tableView cellForRowAtIndexPath:indexPath] atIndexPath:indexPath];
            break;
            
        case NSFetchedResultsChangeMove:
            [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationLeft];
            [tableView insertRowsAtIndexPaths:[NSArray arrayWithObject:newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
            break;
    }
    if ([[self.fetchController fetchedObjects] count] == 0)
    {
        //display an empty indicator image
        [self.noItemsImage setHidden:NO];
        [self.myTableView setHidden:YES];
        [exportButton setEnabled:NO];
        [clearButton setEnabled:NO];
    }
    else
    {
        [self.noItemsImage setHidden:YES];
        [self.myTableView setHidden:NO];
        [self.myTableView reloadData];
        [exportButton setEnabled:YES];
        [clearButton setEnabled:YES];
    }
}

/**
 * Notifies the receiver of the addition or removal of a section. The fetched results controller reports changes to its section before changes to the fetched result objects.
 * @param controller The fetched results controller that sent the message.
 * @param sectionInfo The section that changed.
 * @param sectionIndex The index of the changed section.
 * @param type The type of change (insert or delete). Valid values are NSFetchedResultsChangeInsert and NSFetchedResultsChangeDelete.
 */
- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id )sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type
{
    switch(type)
    {
        case NSFetchedResultsChangeInsert:
            [self.myTableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
            break;
            
        case NSFetchedResultsChangeDelete:
            [self.myTableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationLeft];
            break;
    }
}

/**
 * Notifies the receiver that the fetched results controller has completed processing of one or more changes due to an add, remove, move, or update.
 * @param controller The fetched results controller that sent the message.
 */
- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
    [self.myTableView endUpdates];
}

/***
 * Asks the delegate for the height to use for a row in a specified location.
 * @param tableView The table-view object requesting this information.
 * @param indexPath An index path that locates a row in tableView.
 * @return GGFloat A floating-point value that specifies the height (in points) that row should be.
 */
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    return 72.0;
}

/**
 * Tells the data source to return the number of rows in a given section of a table view. (required)
 * @param tableView The table-view object requesting this information.
 * @param section An index number identifying a section in tableView.
 * @return NSInteger The number of rows in section.
 */
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    NSInteger numberOfRows = 0;
    if ([[self.fetchController sections] count] > 0)
    {
        id <NSFetchedResultsSectionInfo> sectionInfo = [[self.fetchController sections] objectAtIndex:section];
        numberOfRows = [sectionInfo numberOfObjects];
    }
    return numberOfRows;
}

/**
 * Asks the data source to return the number of sections in the table view.
 * @param tableView An object representing the table view requesting this information.
 * @return NSInteger The number of sections in tableView. The default value is 1.
 */
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return [[self.fetchController sections] count];
}

/**
 * Sets the title for the given section.
 * @param tableView An object representing the table view requesting this information.
 * @param section section to set the title to.
 * @return NSString Title of the header for the current section
 */
- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section
{
    return [[[self.fetchController sections] objectAtIndex:section] name];
}

/**
 * Asks the data source for a cell to insert in a particular location of the table view.
 * @param tableView An object representing the table view requesting this information.
 * @param indexPath An index path locating a row in tableView.
 * @return UITableViewCell An object inheriting from UITableViewCell that the table view can use for the specified row. An assertion is raised if you return nil.
 */
- (UITableViewCell*)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    HistoryCell *cell = (HistoryCell*)[tableView dequeueReusableCellWithIdentifier:[HistoryCell reuseIdentifier]];
    [self configureCell:cell atIndexPath:indexPath];
    return cell;
}

/**
 * Configure a given cell to display the name of the activity.
 * @param cell a cell t configure
 * @param indexPath An index path locating a row in tableView.
 */
- (void)configureCell:(HistoryCell *)cell atIndexPath:(NSIndexPath *)indexPath
{
    History *history = [self.fetchController objectAtIndexPath:indexPath];
    [cell.nameLabel setText:history.name];
    NSDateFormatter *f = [self.class dateFormatter];
    [cell.startDateLabel setText:[NSString stringWithFormat:@"%@", [f stringFromDate:history.startDate]]];
    [cell.endDateLabel setText:[NSString stringWithFormat:@"%@", [f stringFromDate:history.endDate]]];
    int duration = [history.duration intValue];
    int seconds = duration % 60;
    int minutes = (duration / 60) % 60;
    int hours = (duration / 3600);
    [cell.durationLabel setText:[NSString stringWithFormat:@"%.2d:%.2d:%.2d", hours, minutes, seconds]];
    if ([[history uploaded] isEqualToNumber:[NSNumber numberWithInt:1]])
    {
        [cell.startDateLabel setTextColor:[UIColor lightGrayColor]];
        [cell.endDateLabel setTextColor:[UIColor lightGrayColor]];
        [cell.durationLabel setTextColor:[UIColor lightGrayColor]];
        [cell.nameLabel setTextColor:[UIColor lightGrayColor]];
    }
}

/**
 * Tells the delegate that the specified row can be edited or not.
 * @param tableView A table-view object informing the delegate about the new row selection.
 * @param indexPath An index path locating the new selected row in tableView.
 */
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath
{
    return YES;
}

/**
 * Called when an editing happened to the cell, in this case: delete. So delete the object from core data.
 * @param tableView tableview where editing will begin
 * @param editingStyle what type editing is happened (add, delete, move)
 * @param indexPath where editing will begin
 */
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath
{
    if (editingStyle == UITableViewCellEditingStyleDelete)
    {
        AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];
        NSManagedObject *historyToDelete = (History*)[self.fetchController objectAtIndexPath:indexPath];
        [appDelegate.managedObjectContext deleteObject:historyToDelete];
        [appDelegate saveContext];
        [self.myTableView reloadData];
    }
}

/**
 * Tells the delegate that the specified row is now selected. Pass the selected activity to the delegate method.
 * @param tableView A table-view object informing the delegate about the new row selection.
 * @param indexPath An index path locating the new selected row in tableView.
 */
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    [tableView deselectRowAtIndexPath:indexPath animated:YES];
}

#pragma mark - view methods
/**
 * Load history entities from core data.
 */
- (void)loadCoreDataEntities
{
    NSError *error = nil;
    if (![self.fetchController performFetch:&error])
    {
        NSLog(@"Error %@, %@", error, [error userInfo]);
    }
    if ([[self.fetchController fetchedObjects] count] == 0)
    {
        //display an empty indicator image
        [self.noItemsImage setHidden:NO];
        [self.myTableView setHidden:YES];
        [exportButton setEnabled:NO];
        [clearButton setEnabled:NO];
    }
    else
    {
        [self.noItemsImage setHidden:YES];
        [self.myTableView setHidden:NO];
        [exportButton setEnabled:YES];
        [clearButton setEnabled:YES];
        [self.myTableView reloadData];
    }
}

/**
 * Handle the save notification.
 * @param aNotification notification to handle.
 */
- (void)handleSaveNotification:(NSNotification *)aNotification
{
    AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];
    [appDelegate.managedObjectContext mergeChangesFromContextDidSaveNotification:aNotification];
}

/**
 * Method to go back to previous controller.
 */
- (void)goBack
{
    CATransition *transition = [CATransition animation];
    transition.duration = 0.5;
    transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
    transition.type = @"alignedCube";
    transition.subtype = kCATransitionFromRight;
    [self.navigationController.view.layer addAnimation:transition forKey:nil];
    [self.navigationController popViewControllerAnimated:YES];
}

/**
 * Called when finish loading the view, load core data entities
 */
- (void)viewDidLoad
{
    [super viewDidLoad];
    self.title = @"History";
    [self.myTableView registerNib:[UINib nibWithNibName:@"HistoryCell" bundle:nil] forCellReuseIdentifier:[HistoryCell reuseIdentifier]];
    self.navigationItem.hidesBackButton = YES;
    self.navigationItem.leftBarButtonItem = [CustomButton createBackButtonWithTitle:@"Back"
                                                                         withTarget:self
                                                                       withSelector:@selector(goBack)];
    [self.view setBackgroundColor:[UIColor colorWithRed:43.0/255.0 green:43.0/255.0 blue:43.0/255.0 alpha:1.0]];
    [self loadCoreDataEntities];
}

/**
 * When view did apper add obsever to handle notifications.
 * @param animated to display animated or not
 */
- (void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];
    AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(handleSaveNotification:)
                                                 name:NSManagedObjectContextDidSaveNotification
                                               object:appDelegate.managedObjectContext];
}

/**
 * When view did disappear remove obsever to handle notifications.
 * @param animated to display animated or not
 */
- (void)viewWillDisappear:(BOOL)animated
{
    [super viewWillDisappear:animated];
    AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name:NSManagedObjectContextDidSaveNotification
                                                  object:appDelegate.managedObjectContext];
}

/**
 * Called when memory warning received.
 */
- (void)didReceiveMemoryWarning
{
    [super didReceiveMemoryWarning];
}

/**
 * Dealloc method to deallocate references and outlets.
 */
- (void)dealloc
{
    [self setNoItemsImage:nil];
    [self setFetchController:nil];
    [self setMyTableView:nil];
    [self setDataExportHelper:nil];
    clearButton = nil;
    exportButton = nil;
}

@end